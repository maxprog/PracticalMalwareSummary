# 4 A crash course in x86 assembly

## The x86 Architecture

The internal of most moderns computers follow the Von Neumann architecture, having 3 hw components:

- Central Processing Unit -> used to execute the code. It contains:
    + Control Unit -> gets instructions from RAM, uses a special register (instruction pointer) to stores the address of the instruction to execute
    + Registers -> data storage for CPU, faster than RAM but way smaller
    + Arithmetic Logic Unit -> Executes instructions and places the results in registers or memory
- Main Memory (RAM) -> stores data and code
- I/O System -> interfaces with devices (hard drives, monitors...)

## Main Memory

The RAM for a single program can be visualized as follows:

> MAIN MEMORY
> Stack - Heap - Code - Data
> Low mem. addr. -> High mem. addr.

- Data: values that are put in place when a program is loaded. *Static* values won't change during the execution, *global* values will be available to any part of the program
- Code: instructions fetched by the CPU to execute program's tasks.
- Heap: used for dynamic memory handling during the execution. It will create (allocate) new values and eliminate (free) values. Its content changes frequently.
- Stack: Used for local variables and parameters for functions, and help control program flow.

## Instructions, endianness and operands

Instructions are building blocks of assembly programs; in x86 an instruction is made of a *mnemonic* and zero or more *operands*. The *mnemonic* is a word that identifies the instruction that will be executed, while *operands* are the information used by the instruction (such as registers or data). Ex: `mov ecx 0x42` -> `mov` is the mnemonic, `ecx` and `0x42` are the operands.

Other important terms:
- **Opcodes** (operation codes) -> translation of the given instruction at the CPU level. Disassemblers are used to translate *opcodes* into instructions.
- **Endianness**: can be *big endian* or *little endian* -> describes how data are represented. In big endian, the most significant bit is at the beginning, the opposite for little endian representation.

**Operands** are used to identify the data used by an instruction; there are 3 types:
- *Immediate*: operands with fixed values
- *Register*: such as `ecx`
- *Memory addresses*, where the value of interest is contained. Denoted by a value or register between brackets, ex `[ecx]`.

## Registers

**Registers** are small amount of data storage available to the CPU; they can be accessed more quickly than memory. Here are the most common types of x86 registers:
- *General registers*: used by the CPU during the execution
- *Segment registers*: used to track memory sections
- *Status flag*: used to make decisions
- *Instruction pointers*: used to keep track of the next instruction to execute

| **General registers**  	| **Segment registers** 	| **Status registers** 	| **Instruction pointer** 	|
|------------------------	|-----------------------	|----------------------	|-------------------------	|
| `EAX` (`AX`,`AH`,`AL`) 	| `CS`                  	| `EFLAGS`             	| `EIP`                   	|
| `EBX` (`BX`,`BH`,`BL`) 	| `SS`                  	|                      	|                         	|
| `ECX` (`CX`,`CB`,`CL`) 	| `DS`                  	|                      	|                         	|
| `EDX` (`DX`,`DH`,`DL`) 	| `ES`                  	|                      	|                         	|
| `EBP` (`BP`)           	| `FS`                  	|                      	|                         	|
| `ESP` (`SP`)           	| `GS`                  	|                      	|                         	|
| `ESI` (`SI`)           	|                       	|                      	|                         	|

### General registers

They are:

- `EAX` (`AX`,`AH`,`AL`),
- `EBX` (`BX`,`BH`,`BL`),
- `ECX` (`CX`,`CH`,`CL`),
- `EDX` (`DX`,`DH`,`DL`),
- `EBP` (`BP`),
- `ESP` (`SP`)
- `ESI` (`SI`)

All the general registers are 32 bits in size and can be referenced as either 32 or 16 bits in assembly, ex: `EDX` is 32 bits, but we can use `DX` to reference the lower 16 bits of the register.

`EAX`, `EBX`, `ECX` and `EDX` can also be referenced as 8-bit values using the lowest 8 bits or the second set of 8 bits. Ex: `AL` is used for the lowest 8 bits, while `AH` for the second set.

Some special x86 instructions use specific registers by definition. For instance, multiplication and division instructions always use `EAX` and `EDX`. Some conventions may be also used, for example the `EAX` register generally contains the return value for function calls.

### Flags

The `EFLAGS` register is a status register, 32 bits in size, where every bit is a flag which can be set (1) or cleared (0) to control or indicate the results of CPU operations. Here are some of the most important flags:

- `ZF`, Zero Flag: set when the result of an operation is equal to zero, cleared otherwise
- `CF`, Carry Flag: set when the result of an operation is too large or too small for the destination operand, cleared otherwise
- `SF`, Sign Flag: set when the result of an operation is negative, cleared otherwise. This flag is also set when the most significant bit is set after an arithmetic operation
- `TF`, Trap Flag: used for debugging, the x86 processor will execute one instruction at the time if this flag is set

### EIP - instruction pointer

In x86 architecture, `EIP` (*instruction pointer* or *program counter*) is a register that contains the memory address of the next instruction to be executed for a program.
